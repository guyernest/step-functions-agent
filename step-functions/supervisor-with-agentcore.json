{
    "Comment": "AI Supervisor Agent with Agent Core Browser Integration",
    "QueryLanguage": "JSONata",
    "StartAt": "Call LLM",
    "States": {
      "Call LLM": {
        "Type": "Task",
        "Resource": "arn:aws:states:::lambda:invoke",
        "Retry": [
          {
            "ErrorEquals": [
              "Lambda.ServiceException",
              "Lambda.AWSLambdaException",
              "Lambda.SdkClientException",
              "Lambda.TooManyRequestsException"
            ],
            "IntervalSeconds": 1,
            "MaxAttempts": 3,
            "BackoffRate": 2,
            "JitterStrategy": "FULL"
          }
        ],
        "Next": "Is done?",
        "Arguments": {
          "Payload": {
            "model_id": "claude-3-haiku-20240307",
            "system": "\n        You are supervisor of a team of expert business analysts. \n        Your team job is to help users understand and analyze their internal data. \n        You have access to a set of tools, which are the different agents. \n        You must use them to complete the tasks. \n        When you see a user request that matches the capabilities of one of the agent, transfer the request to that agent, and don't try to solve it yourself. \n        Please note that the tool result of the agent can include two content parts, text and image. \n        When you are ready to reply to the user, please use the print_output tool to format the reply.\n        ",
            "messages": "{% $states.input.messages %}",
            "tools": [
              {
                "name": "sql_agent",
                "description": "Analyze user request and generate SQL query to extract data from a baseball database, and generate a visualization to answer the user's question.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "question": {
                      "type": "string",
                      "description": "The question of the user."
                    }
                  },
                  "required": [
                    "question"
                  ]
                }
              },
              {
                "name": "research_agent",
                "description": "Provide web research information to answer user's question regarding stock market companies.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "question": {
                      "type": "string",
                      "description": "The question of the user."
                    }
                  },
                  "required": [
                    "question"
                  ]
                }
              },
              {
                "name": "browser_agent",
                "description": "Search for products, prices, and information on web portals like Amazon. Use this for e-commerce searches, price comparisons, and product availability checks.",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "action": {
                      "type": "string",
                      "enum": ["search", "extract", "authenticate"],
                      "description": "The action to perform: search for products, extract data, or authenticate"
                    },
                    "url": {
                      "type": "string",
                      "description": "The URL of the portal (default: https://www.amazon.com)"
                    },
                    "query": {
                      "type": "string",
                      "description": "The search query (for search action)"
                    },
                    "selectors": {
                      "type": "object",
                      "description": "CSS selectors for data extraction (for extract action)"
                    }
                  },
                  "required": [
                    "action"
                  ]
                }
              },
              {
                "name": "print_output",
                "description": "Print the output of the previous steps",
                "input_schema": {
                  "type": "object",
                  "properties": {
                    "answer": {
                      "type": "string",
                      "description": "The answer to users question"
                    }
                  }
                }
              }
            ]
          },
          "FunctionName": "arn:aws:lambda:us-west-2:672915487120:function:CallLLM"
        },
        "Comment": "The main call to the LLM. Returns the list of messages with the current call at the end, and metadata of the last call.",
        "Output": {
          "messages": "{% $states.result.Payload.body.messages%}",
          "metadata": "{% $states.result.Payload.body.metadata%}"
        },
        "Assign": {
          "messages": "{% $states.result.Payload.body.messages%}",
          "provider": "anthropic"
        }
      },
      "Is done?": {
        "Type": "Choice",
        "Default": "For each tool use",
        "Choices": [
          {
            "Condition": "{% $states.input.metadata.stop_reason = \"end_turn\" %}",
            "Next": "Prepare Output"
          },
          {
            "Next": "Print Output",
            "Condition": "{% $count($states.input.messages[-1].content[name = \"print_output\"]) >0 %}"
          }
        ],
        "Comment": "Checks if the 'stop_reason' from the LLM was a request for a 'tool_use' (except for print_output), and if so, route it to the tools path, otherwise reply to the user."
      },
      "Prepare Output": {
        "Type": "Pass",
        "End": true,
        "Output": {
          "messages": "{% $states.input.messages %}",
          "answer": "{% $states.input.messages[-1].content %}"
        },
        "Comment": "Extracts the relevant information from the flow, including all the message flow, the textual answer from the last message, and the chart that was generated during the flow."
      },
      "For each tool use": {
        "Type": "Map",
        "ItemProcessor": {
          "ProcessorConfig": {
            "Mode": "INLINE"
          },
          "StartAt": "Which Tool to Use?",
          "States": {
            "Which Tool to Use?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Condition": "{% ($states.input.type in [\"function\",\"tool_use\"]) and ($states.input.**.name = \"sql_agent\") %}",
                  "Next": "Execute sql_agent"
                },
                {
                  "Condition": "{% ($states.input.type in [\"function\",\"tool_use\"]) and ($states.input.**.name = \"research_agent\") %}",
                  "Next": "Execute research_agent"
                },
                {
                  "Condition": "{% ($states.input.type in [\"function\",\"tool_use\"]) and ($states.input.**.name = \"browser_agent\") %}",
                  "Next": "Execute browser_agent"
                }
              ],
              "Default": "No Tool to Use (ignore)",
              "Comment": "Check if the request is for 'tool_use' and then to which of the available tools to send it."
            },
            "No Tool to Use (ignore)": {
              "Type": "Pass",
              "Output": {},
              "Comment": "This path handles the text replies of the LLM that describe its thinking and don't require any tool to use.",
              "End": true
            },
            "Execute sql_agent": {
              "Type": "Task",
              "Resource": "arn:aws:states:::states:startExecution.sync:2",
              "Arguments": {
                "StateMachineArn": "arn:aws:states:us-west-2:672915487120:stateMachine:QLAgentWithToolsFlowAndClaude",
                "Input": {
                  "messages": [
                    {
                      "role": "user",
                      "content": "{% $states.input.input.question %}"
                    }
                  ]
                }
              },
              "Output": {
                "role": "user",
                "content": [
                  {
                    "type": "tool_result",
                    "tool_use_id": "{% $states.input.**.id %}",
                    "content": "{% $states.result.Output.answer %}"
                  }
                ]
              },
              "Comment": "Calls sql agent's execution and converts the result into a tool result format for the LLM",
              "End": true
            },
            "Execute research_agent": {
              "Type": "Task",
              "Resource": "arn:aws:states:::states:startExecution.sync:2",
              "Arguments": {
                "StateMachineArn": "arn:aws:states:us-west-2:672915487120:stateMachine:WebResearchAgent",
                "Input": {
                  "messages": [
                    {
                      "role": "user",
                      "content": "{% $states.input.input.question %}"
                    }
                  ]
                }
              },
              "Output": {
                "role": "user",
                "content": [
                  {
                    "type": "tool_result",
                    "tool_use_id": "{% $states.input.**.id %}",
                    "content": "{% $states.result.Output.answer %}"
                  }
                ]
              },
              "Comment": "Calls research agent's execution and converts the result into a tool result format for the LLM",
              "End": true
            },
            "Execute browser_agent": {
              "Type": "Task",
              "Resource": "arn:aws:states:::states:startExecution.sync:2",
              "Arguments": {
                "StateMachineArn": "arn:aws:states:us-west-2:672915487120:stateMachine:AgentCoreWrapper-prod",
                "Input": {
                  "action": "{% $states.input.input.action ? $states.input.input.action : 'search' %}",
                  "session_id": "{% $states.context.Execution.Name %}",
                  "url": "{% $states.input.input.url ? $states.input.input.url : 'https://www.amazon.com' %}",
                  "query": "{% $states.input.input.query %}",
                  "selectors": "{% $states.input.input.selectors %}",
                  "config": {}
                }
              },
              "Output": {
                "role": "user",
                "content": [
                  {
                    "type": "tool_result",
                    "tool_use_id": "{% $states.input.**.id %}",
                    "content": "{% $states.result.Output.response ? $states.result.Output.response : $string($states.result.Output.results) %}"
                  }
                ]
              },
              "Comment": "Calls Agent Core browser agent and converts the result into a tool result format",
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "Browser Agent Error Handler"
                }
              ]
            },
            "Browser Agent Error Handler": {
              "Type": "Pass",
              "Output": {
                "role": "user",
                "content": [
                  {
                    "type": "tool_result",
                    "tool_use_id": "{% $states.input.**.id %}",
                    "content": "Browser agent encountered an error. Please try again with a different query."
                  }
                ]
              },
              "End": true
            }
          }
        },
        "Arguments": "{% $states.input.messages[-1].content[($type = \"tool_use\") or (name)] %}",
        "Next": "Call LLM",
        "Output": {
          "messages": "{% $append($states.context.messages, [$states.result[0]]) %}"
        },
        "MaxConcurrency": 1,
        "Comment": "Since we can have multiple tool calls in a single request, we need to use a Map to iterate over them. The result is a formatted tool output list."
      },
      "Print Output": {
        "Type": "Pass",
        "Output": {
          "messages": "{% $states.input.messages %}",
          "answer": "{% $states.input.messages[-1].content[name = \"print_output\"].input.answer %}"
        },
        "End": true
      }
    }
  }